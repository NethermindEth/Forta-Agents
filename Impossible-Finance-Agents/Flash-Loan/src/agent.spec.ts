import {
  Finding,
  FindingType,
  FindingSeverity,
  TransactionEvent,
  HandleTransaction,
} from 'forta-agent';

import {
  createAddress,
  TestTransactionEvent,
} from 'forta-agent-tools';

import {
  provideHandleTransaction,
  PAIR_SWAP_ABI,
} from './agent';

import {
  ethers,
} from 'ethers';

const createFinding = (amount0Out: string, amount1Out: string, to: string, data: string) => Finding.fromObject({
  name: 'Flash Loan Detected',
  description: 'A flash loan has been executed on an Impossible Finance StableXSwap contract',
  alertId: 'IMPOSSIBLE-5',
  severity: FindingSeverity.Info,
  type: FindingType.Info,
  protocol: 'Impossible Finance',
  metadata: {
    amount0Out: amount0Out,
    amount1Out: amount1Out,
    to: to,
    data: data,
  },
});

describe('StableXSwap Flash Loan Agent test suite', () => {
  let handler: HandleTransaction;
  let mockCheckFromFactory: any;
  let contract: ethers.utils.Interface;

  // Set the factory address
  const FACTORY_ADDR = createAddress('0xa1');
  // Set a pair address
  const PAIR_ADDR = createAddress('0xb1');
  // Set a user address
  const USER_ADDR = createAddress('0xc1');
  // Set the loan receiver address
  const RCVR_ADDR = createAddress('0xd1');

  beforeEach(() => {
    // Setup the mock getContractFactory function 
    mockCheckFromFactory = jest.fn();
    // Setup the handler to user the mock getContract function
    handler = provideHandleTransaction(FACTORY_ADDR, mockCheckFromFactory);
    contract = new ethers.utils.Interface(PAIR_SWAP_ABI);
  });

  it('should ignore empty transactions', async () => {
     const tx: TransactionEvent = new TestTransactionEvent();

    // Run the handler on the test transaction
     const findings: Finding[] = await handler(tx);
    // Check if findings contain expected results
     expect(findings).toStrictEqual([]);
  });

  it('should ignore calls to `swap` which are not a flashloan', async () => {
    const tx: TransactionEvent = new TestTransactionEvent()
      // Add a call to the function `swap`
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData(
          'swap',
          [
            ethers.BigNumber.from('0'),
            ethers.BigNumber.from('1000'),
            createAddress('0x0'),
            // The argument `data` is zero, so it is not a flashloan
            ethers.BigNumber.from('0'),
          ],
        ),
        output: '0x0',
      });

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);
    // Check if findings contain expected results
    expect(findings).toStrictEqual([]);
  });

  it('should ignore calls to `swap` which are a flashloan on a pair NOT generated by the Impossible Finance factory', async () => {
    // The mock checkFromFactory function returns false 
    mockCheckFromFactory.mockResolvedValue(false);

    // Create an interface to generate the log data to be attached to the test transaction
    const SWAP_FACTORY_IFACE: ethers.utils.Interface = new ethers.utils.Interface(PAIR_SWAP_ABI);
    const log = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent('Swap'),
      [
        USER_ADDR, ethers.BigNumber.from('0'),
        ethers.BigNumber.from('1010'),
        ethers.BigNumber.from('0'),
        ethers.BigNumber.from('1000'),
        RCVR_ADDR
      ],
    );

    const tx: TransactionEvent = new TestTransactionEvent()
      // Add the function call to `swap`
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData(
          'swap',
          [
            ethers.BigNumber.from('0'),
            ethers.BigNumber.from('1000'),
            RCVR_ADDR,
            ethers.BigNumber.from('100'),
          ],
        ),
        output: '0x0',
      })
      // Add the log indicating a successful call to `swap`
      .addAnonymousEventLog(
        PAIR_ADDR,
        log.data,
        ...log.topics,
      );

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);
    // Check if findings contain expected results
    expect(findings).toStrictEqual([]);
  });

  it('should detect calls to `swap` which are a flashloan on a pair generated by the Impossible Finance factory', async () => {
    // The mock checkFromFactory function returns true
    mockCheckFromFactory.mockResolvedValue(true);

    // Create an interface to generate the log data to be attached to the test transaction
    const SWAP_FACTORY_IFACE: ethers.utils.Interface = new ethers.utils.Interface(PAIR_SWAP_ABI);
    const log = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent('Swap'),
      [
        USER_ADDR, ethers.BigNumber.from('0'),
        ethers.BigNumber.from('1010'),
        ethers.BigNumber.from('0'),
        ethers.BigNumber.from('1000'),
        RCVR_ADDR
      ],
    );

    const tx: TransactionEvent = new TestTransactionEvent()
      // Add the function call to `swap`
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData(
          'swap',
          [
            ethers.BigNumber.from('0'),
            ethers.BigNumber.from('1000'),
            RCVR_ADDR,
            ethers.BigNumber.from('100'),
          ],
        ),
        output: '0x0',
      })
      // Add the log indicating a successful call to `swap`
      .addAnonymousEventLog(
        PAIR_ADDR,
        log.data,
        ...log.topics,
      );

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);

    // Check if findings contain expected results
    expect(findings).toStrictEqual([
      createFinding(
        '0',
        '1000',
        RCVR_ADDR,
        ethers.BigNumber.from('100').toHexString(),
      ),
    ]);
  });

  it('should detect multiple calls to `swap` which are a flashloan on a pair generated by the Impossible Finance factory', async () => {
    // The mock checkFromFactory function returns true
    mockCheckFromFactory.mockResolvedValue(true);

    // Create an interface to generate the log1 data to be attached to the test transaction
    const SWAP_FACTORY_IFACE: ethers.utils.Interface = new ethers.utils.Interface(PAIR_SWAP_ABI);
    const log1 = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent('Swap'),
      [
        USER_ADDR,
        ethers.BigNumber.from('0'),
        ethers.BigNumber.from('1010'),
        ethers.BigNumber.from('0'),
        ethers.BigNumber.from('1000'),
        RCVR_ADDR
      ],
    );
    const log2 = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent('Swap'),
      [
        USER_ADDR,
        ethers.BigNumber.from('0'),
        ethers.BigNumber.from('2020'),
        ethers.BigNumber.from('0'),
        ethers.BigNumber.from('2000'),
        RCVR_ADDR
      ],
    );

    const tx: TransactionEvent = new TestTransactionEvent()
      // Add the function call to `swap` (first call)
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData(
          'swap',
          [
            ethers.BigNumber.from('0'),
            ethers.BigNumber.from('1000'),
            RCVR_ADDR,
            ethers.BigNumber.from('100'),
          ],
        ),
        output: '0x0',
      })
      // Add the log1 indicating a successful call to `swap` (first call)
      .addAnonymousEventLog(
        PAIR_ADDR,
        log1.data,
        ...log1.topics,
      )
      // Add the function call to `swap` (second call)
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData(
          'swap',
          [
            ethers.BigNumber.from('0'),
            ethers.BigNumber.from('2000'),
            RCVR_ADDR,
            ethers.BigNumber.from('200'),
          ],
        ),
        output: '0x0',
      })
      // Add the log1 indicating a successful call to `swap` (second call)
      .addAnonymousEventLog(
        PAIR_ADDR,
        log2.data,
        ...log2.topics,
      );

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);

    // Check if findings contain expected results
    expect(findings).toStrictEqual([
      createFinding(
        '0',
        '1000',
        RCVR_ADDR,
        ethers.BigNumber.from('100').toHexString(),
      ),
      createFinding(
        '0',
        '2000',
        RCVR_ADDR,
        ethers.BigNumber.from('200').toHexString(),
      ),
    ]);
  });
});
