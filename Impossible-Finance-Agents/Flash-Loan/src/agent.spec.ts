import {
  Finding,
  FindingType,
  FindingSeverity,
  TransactionEvent,
  HandleTransaction,
} from "forta-agent";

import {
  createAddress,
  TestTransactionEvent,
} from "forta-agent-tools/lib/tests";

import { provideHandleTransaction } from "./agent";

import { ethers } from "ethers";
import { PAIR_SWAP_ABI } from "./utils";

const createFinding = (
  amount0Out: string,
  amount1Out: string,
  to: string,
  data: string
) =>
  Finding.fromObject({
    name: "Flash Loan Detected",
    description:
      "A flash loan has been executed on an Impossible Finance StableXSwap contract",
    alertId: "IMPOSSIBLE-5",
    severity: FindingSeverity.Info,
    type: FindingType.Info,
    protocol: "Impossible Finance",
    metadata: {
      amount0Out: amount0Out,
      amount1Out: amount1Out,
      to: to,
      data: data,
    },
  });

describe("StableXSwap Flash Loan Agent test suite", () => {
  let handler: HandleTransaction;
  let mockCheckFromFactory: any;
  let contract: ethers.utils.Interface;

  // Set the factory address
  const FACTORY_ADDR = createAddress("0xa1");
  // Set a pair address
  const PAIR_ADDR = createAddress("0xb1");
  // Set a user address
  const USER_ADDR = createAddress("0xc1");
  // Set the loan receiver address
  const RCVR_ADDR = createAddress("0xd1");

  beforeEach(() => {
    // Setup the mock getContractFactory function
    mockCheckFromFactory = jest.fn();
    // Setup the handler to user the mock getContract function
    handler = provideHandleTransaction(FACTORY_ADDR, mockCheckFromFactory);
    contract = new ethers.utils.Interface(PAIR_SWAP_ABI);
  });

  it("should ignore empty transactions", async () => {
    const tx: TransactionEvent = new TestTransactionEvent();

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);
    // Check if findings contain expected results
    expect(findings).toStrictEqual([]);
  });

  it("should ignore calls to `swap` which are not a flashloan", async () => {
    const tx: TransactionEvent = new TestTransactionEvent()
      // Add a call to the function `swap`
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData("swap", [
          ethers.BigNumber.from("0"),
          ethers.BigNumber.from("1000"),
          createAddress("0x0"),
          // The argument `data` is zero, so it is not a flashloan
          ethers.BigNumber.from("0"),
        ]),
        output: "0x0",
      });

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);
    // Check if findings contain expected results
    expect(findings).toStrictEqual([]);
  });

  it("should ignore calls to `swap` which are a flashloan on a pair NOT generated by the Impossible Finance factory", async () => {
    // The mock checkFromFactory function returns false
    mockCheckFromFactory.mockResolvedValue(false);

    // Create an interface to generate the log data to be attached to the test transaction
    const SWAP_FACTORY_IFACE: ethers.utils.Interface =
      new ethers.utils.Interface(PAIR_SWAP_ABI);
    const log = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent("Swap"),
      [
        USER_ADDR,
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("1010"),
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("1000"),
        RCVR_ADDR,
      ]
    );

    const tx: TransactionEvent = new TestTransactionEvent()
      // Add the function call to `swap`
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData("swap", [
          ethers.BigNumber.from("0"),
          ethers.BigNumber.from("1000"),
          RCVR_ADDR,
          ethers.BigNumber.from("100"),
        ]),
        output: "0x0",
      })
      // Add the log indicating a successful call to `swap`
      .addAnonymousEventLog(PAIR_ADDR, log.data, ...log.topics);

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);
    // Check if findings contain expected results
    expect(findings).toStrictEqual([]);
  });

  it("should detect calls to `swap` which are a flashloan on a pair generated by the Impossible Finance factory", async () => {
    // The mock checkFromFactory function returns true
    mockCheckFromFactory.mockResolvedValue(true);

    // Create an interface to generate the log data to be attached to the test transaction
    const SWAP_FACTORY_IFACE: ethers.utils.Interface =
      new ethers.utils.Interface(PAIR_SWAP_ABI);
    const log = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent("Swap"),
      [
        USER_ADDR,
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("1010"),
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("1000"),
        RCVR_ADDR,
      ]
    );

    const tx: TransactionEvent = new TestTransactionEvent()
      // Add the function call to `swap`
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData("swap", [
          ethers.BigNumber.from("0"),
          ethers.BigNumber.from("1000"),
          RCVR_ADDR,
          ethers.BigNumber.from("100"),
        ]),
        output: "0x0",
      })
      // Add the log indicating a successful call to `swap`
      .addAnonymousEventLog(PAIR_ADDR, log.data, ...log.topics);

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);

    // Check if findings contain expected results
    expect(findings).toStrictEqual([
      createFinding(
        "0",
        "1000",
        RCVR_ADDR,
        ethers.BigNumber.from("100").toHexString()
      ),
    ]);
  });

  it("should detect multiple calls to `swap` which are a flashloan on a pair generated by the Impossible Finance factory", async () => {
    // The mock checkFromFactory function returns true
    mockCheckFromFactory.mockResolvedValue(true);

    // Create an interface to generate the log1 data to be attached to the test transaction
    const SWAP_FACTORY_IFACE: ethers.utils.Interface =
      new ethers.utils.Interface(PAIR_SWAP_ABI);
    const log1 = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent("Swap"),
      [
        USER_ADDR,
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("1010"),
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("1000"),
        RCVR_ADDR,
      ]
    );
    const log2 = SWAP_FACTORY_IFACE.encodeEventLog(
      SWAP_FACTORY_IFACE.getEvent("Swap"),
      [
        USER_ADDR,
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("2020"),
        ethers.BigNumber.from("0"),
        ethers.BigNumber.from("2000"),
        RCVR_ADDR,
      ]
    );

    const tx: TransactionEvent = new TestTransactionEvent()
      // Add the function call to `swap` (first call)
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData("swap", [
          ethers.BigNumber.from("0"),
          ethers.BigNumber.from("1000"),
          RCVR_ADDR,
          ethers.BigNumber.from("100"),
        ]),
        output: "0x0",
      })
      // Add the log1 indicating a successful call to `swap` (first call)
      .addAnonymousEventLog(PAIR_ADDR, log1.data, ...log1.topics)
      // Add the function call to `swap` (second call)
      .addTraces({
        to: PAIR_ADDR,
        from: USER_ADDR,
        input: contract.encodeFunctionData("swap", [
          ethers.BigNumber.from("0"),
          ethers.BigNumber.from("2000"),
          RCVR_ADDR,
          ethers.BigNumber.from("200"),
        ]),
        output: "0x0",
      })
      // Add the log1 indicating a successful call to `swap` (second call)
      .addAnonymousEventLog(PAIR_ADDR, log2.data, ...log2.topics);

    // Run the handler on the test transaction
    const findings: Finding[] = await handler(tx);

    // Check if findings contain expected results
    expect(findings).toStrictEqual([
      createFinding(
        "0",
        "1000",
        RCVR_ADDR,
        ethers.BigNumber.from("100").toHexString()
      ),
      createFinding(
        "0",
        "2000",
        RCVR_ADDR,
        ethers.BigNumber.from("200").toHexString()
      ),
    ]);
  });
});
